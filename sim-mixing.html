<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Entropy Mixing Simulator (Red/Blue)</title>
  <style>
    :root {
      --bg: #0f1220; --panel:#171a2b; --text:#e6e8ef; --muted:#9aa0b4; --accent:#78a8ff;
      --red:#ff4d4d; --blue:#4d9bff; --green:#51d19a; --yellow:#ffd166;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 20px; margin: 0 0 8px; letter-spacing:.2px }
    .sub { color: var(--muted); margin-bottom: 16px; }
    .grid { display: grid; grid-template-columns: 1.2fr .8fr; gap: 16px; }
    .card { background: var(--panel); border-radius: 16px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .row > * { margin: 4px 0; }
    label { font-size: 12px; color: var(--muted); }
    input[type=range] { width: 180px; }
    button { background: #222742; color: var(--text); border: 1px solid #30365c; padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 600; }
    button:hover { background: #283059; }
    .pill { padding: 6px 10px; border-radius: 999px; background: #1e2444; border:1px solid #2a315e; font-size: 12px; }
    .legend { display:flex; align-items:center; gap:8px; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .stat { font-variant-numeric: tabular-nums; font-weight:600; }
    canvas { display:block; width:100%; height:auto; border-radius: 12px; background: #0b0e1a; }
    .small { font-size: 12px; color: var(--muted); }
    .side { display: grid; grid-template-rows: auto auto auto auto 1fr; gap: 12px; }
    .meterWrap { background:#0b0e1a; border:1px solid #283059; border-radius:12px; height: 10px; overflow:hidden; }
    .meterBar { height:100%; width:0%; background: linear-gradient(90deg, var(--green), var(--yellow)); }
    .sep { height:1px; background:#2a315e; margin:12px 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <div style="margin-bottom:8px"><a href="index.html#page-sim" style="color:#9aa0b4; text-decoration:none; border:1px solid #2a315e; padding:6px 10px; border-radius:8px">← 갤러리로</a></div>
    <h1>엔트로피 혼합 시뮬레이터 (빨강/파랑, 2칸 모델)</h1>
    <div class="sub">처음엔 왼쪽에 빨강, 오른쪽에 파랑 입자를 두고 중앙의 작은 문(개구)만 통해 서로 섞입니다. 조합론적 볼츠만 엔트로피 <code>S = k ln W</code> (여기선 <code>k=1</code>)와 열의 이동 기반 엔트로피 <code>\(\sum \Delta Q/T\)</code>를 함께 봅니다.</div>

    <div class="grid">
      <div class="card">
        <canvas id="sim" width="900" height="420"></canvas>
        <div class="row" style="justify-content:space-between; margin-top:10px">
          <div class="row">
            <span class="legend"><span class="dot" style="background:var(--red)"></span>빨강: <span id="rLeft" class="stat">0</span>L / <span id="rRight" class="stat">0</span>R</span>
            <span class="legend" style="margin-left:12px"><span class="dot" style="background:var(--blue)"></span>파랑: <span id="bLeft" class="stat">0</span>L / <span id="bRight" class="stat">0</span>R</span>
            <span class="pill">문 높이: <span id="gatePerc">40</span>%</span>
          </div>
          <div class="row">
            <button id="toggle">⏯︎ 일시정지</button>
            <button id="reset">🔄 리셋</button>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="card">
          <div class="row" style="justify-content:space-between">
            <div>
              <div class="small">볼츠만 엔트로피 S(t) / S<sub>max</sub></div>
              <div class="meterWrap"><div id="meter" class="meterBar"></div></div>
            </div>
            <div class="stat">현재: <span id="Snow">0.000</span></div>
          </div>
          <div class="sep"></div>
          <canvas id="chart" width="480" height="220"></canvas>
          <div class="small">녹색 선: S(t) / S<sub>max</sub>. 최대는 각 색 입자가 좌/우 반씩일 때입니다.</div>
        </div>

        <div class="card" id="heatCard">
          <div class="row" style="justify-content:space-between; align-items:flex-start">
            <div>
              <div class="small">온도 추정 (k<sub>B</sub>=1, m=1, 2D: ⟨KE⟩=kT ⇒ T=⟨0.5v²⟩)</div>
              <div class="row">
                <span class="pill">왼쪽 T<sub>L</sub>: <span id="TL">0.000</span></span>
                <span class="pill">오른쪽 T<sub>R</sub>: <span id="TR">0.000</span></span>
              </div>
            </div>
            <div>
              <div class="small">열 엔트로피(누적)</div>
              <div class="row">
                <span class="pill">ΔS<sub>Q</sub>: <span id="SQ">0.000</span></span>
                <span class="pill">Q<sub>L</sub>: <span id="QL">0.000</span></span>
                <span class="pill">Q<sub>R</sub>: <span id="QR">0.000</span></span>
              </div>
            </div>
          </div>
          <div class="small" style="margin-top:6px">입자가 문을 통과할 때 운동에너지를 해당 칸으로 전달된 열로 보고 ΔS=Σ(ΔQ/T)로 누적합니다.</div>
        </div>

        <div class="card" id="tempControls">
          <div class="row" style="justify-content:space-between">
            <div class="row">
              <label>왼쪽 초기 온도 T<sub>L0</sub></label>
              <input id="TL0Input" type="range" min="0.2" max="5.0" step="0.1" value="1.0" />
              <span class="stat" id="TL0Label">1.0</span>
            </div>
            <div class="row">
              <label>오른쪽 초기 온도 T<sub>R0</sub></label>
              <input id="TR0Input" type="range" min="0.2" max="5.0" step="0.1" value="1.0" />
              <span class="stat" id="TR0Label">1.0</span>
            </div>
          </div>
          <div class="row" style="justify-content:flex-end">
            <button id="applyTemps">온도 슬라이더 적용</button>
          </div>
          <div class="small">슬라이더를 바꾸고 "온도 슬라이더 적용"을 누르면 현재 각 칸의 속도 분포를 해당 목표 온도로 <b>재가열/냉각(스케일링)</b> 합니다. 리셋 시에도 슬라이더 값이 초기 조건으로 반영됩니다.</div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between">
            <div class="row">
              <label>입자(각 색)</label>
              <input id="nInput" type="range" min="20" max="200" step="10" value="80" />
              <span class="stat" id="nLabel">80</span>
            </div>
            <div class="row">
              <label>속도 배율</label>
              <input id="vInput" type="range" min="0.4" max="3.0" step="0.1" value="1.3" />
              <span class="stat" id="vLabel">1.3</span>
            </div>
          </div>
          <div class="row" style="justify-content:space-between; margin-top:8px">
            <div class="row">
              <label>문 높이(%)</label>
              <input id="gInput" type="range" min="0" max="100" step="5" value="40" />
            </div>
            <div class="row">
              <label>문 폭</label>
              <input id="gwInput" type="range" min="4" max="20" step="1" value="8" />
              <span class="stat" id="gwLabel">8px</span>
            </div>
          </div>
          <div class="small" style="margin-top:6px">문이 작을수록(개구율↓) 확산이 느려집니다 → 엔트로피 증가가 천천히 진행됩니다.</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  function buildLogFact(maxN) { const lf = new Float64Array(maxN+1); lf[0]=0; for(let i=1;i<=maxN;i++) lf[i]=lf[i-1]+Math.log(i); return lf; }
  function lnChoose(n,k,lf){ if(k<0||k>n) return -Infinity; return lf[n]-lf[k]-lf[n-k]; }
  function randn(){ let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

  const sim = document.getElementById('sim');
  const ctx = sim.getContext('2d');
  const chart = document.getElementById('chart');
  const cctx = chart.getContext('2d');

  const W = sim.width, H = sim.height; const midX = W/2;
  let gatePct = 40; let gateWidth = 8; const radius = 3.2;
  let speedScale = 1.3; let NperColor = 80; let running = true;

  const rL = document.getElementById('rLeft'); const rR = document.getElementById('rRight');
  const bL = document.getElementById('bLeft'); const bR = document.getElementById('bRight');
  const Sspan = document.getElementById('Snow'); const meter = document.getElementById('meter');
  const gatePercSpan = document.getElementById('gatePerc'); const gwLabel = document.getElementById('gwLabel');

  const TLspan = document.getElementById('TL'); const TRspan = document.getElementById('TR');
  const SQspan = document.getElementById('SQ'); const QLspan = document.getElementById('QL'); const QRspan = document.getElementById('QR');

  const TL0Input = document.getElementById('TL0Input'); const TR0Input = document.getElementById('TR0Input');
  const TL0Label = document.getElementById('TL0Label'); const TR0Label = document.getElementById('TR0Label');
  const applyTempsBtn = document.getElementById('applyTemps');

  const nInput = document.getElementById('nInput'); const vInput = document.getElementById('vInput');
  const gInput = document.getElementById('gInput'); const gwInput = document.getElementById('gwInput');
  const nLabel = document.getElementById('nLabel');

  document.getElementById('toggle').onclick = () => { running=!running; }
  document.getElementById('reset').onclick = resetAll;
  nInput.oninput = (e)=>{ NperColor = +e.target.value; nLabel.textContent = NperColor; resetAll(); }
  vInput.oninput = (e)=>{ speedScale = +e.target.value; document.getElementById('vLabel').textContent = speedScale.toFixed(1); }
  gInput.oninput = (e)=>{ gatePct = +e.target.value; gatePercSpan.textContent = gatePct; }
  gwInput.oninput = (e)=>{ gateWidth = +e.target.value; gwLabel.textContent = gateWidth+"px"; }
  TL0Input.oninput = ()=>{ TL0Label.textContent = (+TL0Input.value).toFixed(1); };
  TR0Input.oninput = ()=>{ TR0Label.textContent = (+TR0Input.value).toFixed(1); };
  applyTempsBtn.onclick = ()=>{ rethermalize('L', +TL0Input.value); rethermalize('R', +TR0Input.value); };

  let particles = [];
  let logFact = buildLogFact(20000);
  let maxLogW = 0; const kB = 1;
  let QL = 0, QR = 0, SQ = 0;

  function initParticles() {
    particles = [];
    for(let i=0;i<NperColor;i++) particles.push(makeParticle(true));
    for(let i=0;i<NperColor;i++) particles.push(makeParticle(false));
    const lnWmaxRed = lnChoose(NperColor, Math.floor(NperColor/2), logFact);
    const lnWmaxBlue = lnChoose(NperColor, Math.floor(NperColor/2), logFact);
    maxLogW = lnWmaxRed + lnWmaxBlue;
    history = []; t = 0; QL = 0; QR = 0; SQ = 0;
    rethermalize('L', +TL0Input.value);
    rethermalize('R', +TR0Input.value);
  }

  function makeParticle(isRed){
    let x, y;
    if(isRed) { x = Math.random()*(midX - 2*radius) + radius; } else { x = Math.random()*(midX - 2*radius) + midX + radius; }
    y = Math.random()*(H - 2*radius) + radius;
    let vx = randn(), vy = randn();
    return {x,y,vx,vy, red:isRed};
  }

  function rethermalize(side, Ttarget){
    const leftSide = (side==='L');
    let count=0, sumKE=0;
    for(const p of particles){
      const isLeft = p.x < midX;
      if((leftSide && isLeft) || (!leftSide && !isLeft)){
        count++; sumKE += 0.5*(p.vx*p.vx + p.vy*p.vy);
      }
    }
    if(count===0) return;
    let Tcurr = sumKE / count; if(!isFinite(Tcurr) || Tcurr<=0) Tcurr = 1e-6;
    const s = Math.sqrt(Ttarget / Tcurr);
    for(const p of particles){
      const isLeft = p.x < midX;
      if((leftSide && isLeft) || (!leftSide && !isLeft)){
        p.vx *= s; p.vy *= s;
      }
    }
  }

  function entropyNow(){
    let rLcount=0, bLcount=0, leftCount=0, rightCount=0, sumKEL=0, sumKER=0;
    for(const p of particles){
      const left = (p.x < midX);
      const KE = 0.5*(p.vx*p.vx + p.vy*p.vy);
      if(left){ leftCount++; sumKEL += KE; if(p.red) rLcount++; else bLcount++; }
      else { rightCount++; sumKER += KE; }
    }
    const rRcount = NperColor - rLcount; const bRcount = NperColor - bLcount;
    rL.textContent = rLcount; rR.textContent = rRcount; bL.textContent = bLcount; bR.textContent = bRcount;

    const lnW = lnChoose(NperColor, rLcount, logFact) + lnChoose(NperColor, bLcount, logFact);
    const S = kB * lnW; const Smax = kB * maxLogW;
    const Snorm = Math.max(0, Math.min(1, S / Smax));
    Sspan.textContent = Snorm.toFixed(3); meter.style.width = (Snorm*100).toFixed(1)+"%";

    const TL = leftCount>0 ? (sumKEL/leftCount) : 0; const TR = rightCount>0 ? (sumKER/rightCount) : 0;
    TLspan.textContent = TL.toFixed(3); TRspan.textContent = TR.toFixed(3);
    SQspan.textContent = SQ.toFixed(3); QLspan.textContent = QL.toFixed(3); QRspan.textContent = QR.toFixed(3);

    return Snorm;
  }

  function step(dt){
    const openHalf = (gatePct/100) * (H/2); const gateTop = H/2 - openHalf, gateBot = H/2 + openHalf;
    for(const p of particles){
      const prevLeft = (p.x < midX);
      p.x += p.vx * speedScale * dt; p.y += p.vy * speedScale * dt;
      if(p.y < radius){ p.y = radius; p.vy *= -1; }
      else if(p.y > H - radius) { p.y = H - radius; p.vy *= -1; }
      if(p.x < radius){ p.x = radius; p.vx *= -1; }
      else if(p.x > W - radius){ p.x = W - radius; p.vx *= -1; }
      const nearWall = Math.abs(p.x - midX) <= (gateWidth/2 + radius);
      const withinGate = (p.y >= gateTop && p.y <= gateBot);
      if(nearWall){
        if(!withinGate){
          if(p.x < midX) { p.x = midX - (gateWidth/2 + radius); }
          else { p.x = midX + (gateWidth/2 + radius); }
          p.vx *= -1;
        }
      }
      const nowLeft = (p.x < midX);
      if(withinGate && (prevLeft !== nowLeft)){
        const KE = 0.5*(p.vx*p.vx + p.vy*p.vy);
        let lCount=0,rCount=0,sumL=0,sumR=0;
        for(const q of particles){ const left = (q.x < midX); const ke = 0.5*(q.vx*q.vx + q.vy*q.vy); if(left){ lCount++; sumL+=ke; } else { rCount++; sumR+=ke; } }
        const TL = lCount? (sumL/lCount) : 1e-6; const TR = rCount? (sumR/rCount) : 1e-6;
        if(prevLeft && !nowLeft){ QL -= KE; QR += KE; SQ += (-KE)/TL + (KE)/TR; }
        else if(!prevLeft && nowLeft){ QR -= KE; QL += KE; SQ += (-KE)/TR + (KE)/TL; }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H); ctx.fillStyle = '#0b0e1a'; ctx.fillRect(0,0,W,H);
    const openHalf = (gatePct/100) * (H/2); const gateTop = H/2 - openHalf, gateBot = H/2 + openHalf;
    ctx.fillStyle = '#263055'; ctx.fillRect(midX - gateWidth/2, 0, gateWidth, gateTop); ctx.fillRect(midX - gateWidth/2, gateBot, gateWidth, H-gateBot);
    const grad = ctx.createLinearGradient(midX-8, 0, midX+8, 0); grad.addColorStop(0, 'rgba(120,168,255,0)'); grad.addColorStop(0.5, 'rgba(120,168,255,0.22)'); grad.addColorStop(1, 'rgba(120,168,255,0)'); ctx.fillStyle = grad; ctx.fillRect(midX-12, gateTop, 24, gateBot-gateTop);
    for(const p of particles){ ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, 2*Math.PI); ctx.fillStyle = p.red ? 'rgba(255,77,77,0.95)' : 'rgba(77,155,255,0.95)'; ctx.fill(); }
  }

  let history = []; let t = 0;
  function drawChart(){
    const padding = 28; const w = chart.width, h = chart.height; cctx.clearRect(0,0,w,h);
    cctx.strokeStyle = '#32406f'; cctx.lineWidth = 1; cctx.beginPath(); cctx.moveTo(padding, h - padding); cctx.lineTo(w - padding, h - padding); cctx.moveTo(padding, h - padding); cctx.lineTo(padding, padding); cctx.stroke();
    cctx.fillStyle = '#9aa0b4'; cctx.font = '12px ui-sans-serif';
    for(const v of [0,0.5,1]){ const y = (h - padding) - v*(h - 2*padding); cctx.fillText(v.toFixed(1), 6, y+4); cctx.strokeStyle = 'rgba(154,160,180,0.12)'; cctx.beginPath(); cctx.moveTo(padding, y); cctx.lineTo(w - padding, y); cctx.stroke(); }
    if(history.length<2) return; const tMin = history[0][0]; const tMax = history[history.length-1][0];
    const xFor = (tt)=> padding + (tt - tMin) / Math.max(1e-6, (tMax - tMin)) * (w - 2*padding); const yFor = (s)=> (h - padding) - s*(h - 2*padding);
    cctx.lineWidth = 2; cctx.strokeStyle = '#51d19a'; cctx.beginPath(); cctx.moveTo(xFor(history[0][0]), yFor(history[0][1])); for(const [tt, ss] of history){ cctx.lineTo(xFor(tt), yFor(ss)); } cctx.stroke();
  }

  let last= performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/16); last = now; if(running){ step(dt); }
    const s = entropyNow(); if(history.length===0 || (t - history[history.length-1][0])>0.05){ history.push([t, s]); if(history.length>1200) history.shift(); }
    draw(); drawChart(); if(running) t += dt*0.016*60; requestAnimationFrame(loop);
  }

  function resetAll(){ initParticles(); }
  resetAll(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
